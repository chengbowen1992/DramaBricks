<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å•äººçƒ­èº«èµ› - DramaBricks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html {
            height: 100%;
            overflow: hidden;
        }
        body {
            background: linear-gradient(135deg, #1a1a3e 0%, #2d2d6d 100%);
            background-attachment: fixed;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100%;
            height: 100%;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            color: white;
            overflow: hidden;
        }

        /* è¿”å›æŒ‰é’® */
        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            text-decoration: none;
            font-size: 16px;
            transition: all 0.3s;
            z-index: 100;
        }
        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateX(-5px);
        }

        /* è°ƒè¯•æ§åˆ¶é¢æ¿ */
        .debug-panel {
            position: fixed;
            top: 130px;
            right: 20px;
            background: rgba(22, 33, 62, 0.95);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: none;
            flex-direction: column;
            gap: 15px;
            min-width: 250px;
            max-height: 60vh;
            overflow-y: auto;
        }
        .debug-panel.visible {
            display: flex;
        }
        .debug-section {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 12px;
        }
        .debug-section:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .debug-label {
            font-size: 12px;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .debug-value {
            color: #4ade80;
            font-weight: bold;
        }
        .debug-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #444;
            outline: none;
            cursor: pointer;
        }
        .debug-slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4ade80;
            cursor: pointer;
        }
        .debug-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4ade80;
            cursor: pointer;
            border: none;
        }
        .debug-hint {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
        }
        .emoji-btn {
            width: 36px;
            height: 36px;
            border: 2px solid #444;
            background: #2a2a3e;
            border-radius: 6px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .emoji-btn:hover {
            border-color: #4ade80;
            background: #3a3a4e;
            transform: scale(1.1);
        }
        .emoji-btn.active {
            border-color: #4ade80;
            background: #4ade80;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }

        /* å¼€å…³å®¹å™¨ */
        .toggle-container {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        /* è°ƒè¯•æ§åˆ¶é¢æ¿ */
        .debug-toggle {
            background: rgba(22, 33, 62, 0.9);
            padding: 12px 20px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .camera-toggle input[type="checkbox"]:checked {
            background: #3b82f6;
        }
        .debug-toggle label {
            font-size: 14px;
            cursor: pointer;
            user-select: none;
        }
        .debug-toggle input[type="checkbox"] {
            width: 40px;
            height: 20px;
            cursor: pointer;
            appearance: none;
            background: #444;
            border-radius: 10px;
            position: relative;
            transition: background 0.3s;
        }
        .debug-toggle input[type="checkbox"]:checked {
            background: #4ade80;
        }
        .debug-toggle input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }
        .debug-toggle input[type="checkbox"]:checked::before {
            left: 22px;
        }

        .main-container {
            display: flex;
            justify-content: center;
            padding: 20px;
            align-items: flex-start;
            transform-origin: center center;
            transition: transform 0.3s ease;
        }

        /* è§†é¢‘é¢æ¿ - å›ºå®šåœ¨å·¦ä¾§ */
        .video-panel {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(22, 33, 62, 0.8);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 50;
        }
        .video-panel.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        .video-panel h3 {
            margin-bottom: 10px;
            color: #56ab2f;
            font-size: 14px;
            text-align: center;
        }
        #videoCanvas {
            border-radius: 8px;
            transform: scaleX(-1);
            width: 320px;
            height: 180px;
        }

        /* æ¸¸æˆé¢æ¿ */
        .game-panel {
            background: rgba(22, 33, 62, 0.8);
            border: 3px solid #56ab2f;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(86, 171, 47, 0.3);
        }
        .game-panel h2 {
            margin-bottom: 10px;
            color: #a8e063;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(168, 224, 99, 0.5);
        }

        /* é¡¶éƒ¨ä¿¡æ¯æ  */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        .header-item {
            flex: 0.8;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 6px;
            background: linear-gradient(135deg, rgba(86, 171, 47, 0.2), rgba(168, 224, 99, 0.1));
            border: 2px solid rgba(168, 224, 99, 0.3);
            border-radius: 8px;
            min-height: 50px;
        }
        .header-item.avatar {
            flex: 1.5;
            padding: 8px;
            min-height: 80px;
        }
        .header-label {
            font-size: 9px;
            color: #a8e063;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 3px;
            opacity: 0.8;
        }
        .header-value {
            font-size: 18px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 0 0 8px rgba(168, 224, 99, 0.5);
        }
        .avatar-circle {
            width: 70px;
            height: 70px;
            border-radius: 12px;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border: 3px solid #fbbf24;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-shadow:
                0 0 15px rgba(251, 191, 36, 0.6),
                inset 0 2px 4px rgba(255, 255, 255, 0.3);
            animation: avatarGlow 2s ease-in-out infinite;
        }
        .avatar-circle img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        @keyframes avatarGlow {
            0%, 100% {
                box-shadow:
                    0 0 15px rgba(251, 191, 36, 0.6),
                    inset 0 2px 4px rgba(255, 255, 255, 0.3);
            }
            50% {
                box-shadow:
                    0 0 25px rgba(251, 191, 36, 0.8),
                    inset 0 2px 4px rgba(255, 255, 255, 0.3);
            }
        }

        #gameCanvas {
            border-radius: 8px;
            background: #0f0f23;
        }

        /* ä¿¡æ¯æ˜¾ç¤º - å·²ç§»é™¤ï¼Œç°åœ¨ä½¿ç”¨é¡¶éƒ¨æ  */

        .status {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
            text-align: center;
        }
        .status .active { color: #4ade80; }

        /* æ¸¸æˆç»“æŸè¦†ç›–å±‚ */
        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 200;
        }
        .game-over-overlay.show {
            display: flex;
        }
        .game-over-text {
            font-size: 48px;
            font-weight: bold;
            color: #a8e063;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(168, 224, 99, 0.6);
        }
        .game-over-stats {
            font-size: 24px;
            margin-bottom: 30px;
            color: #fff;
        }
        .home-btn {
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            transition: all 0.3s;
            margin-bottom: 15px;
        }
        .home-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.5);
        }
        .restart-btn {
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            color: #000;
            font-weight: bold;
            transition: all 0.3s;
        }
        .restart-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(86, 171, 47, 0.5);
        }

        /* ç§»åŠ¨è®¾å¤‡å“åº”å¼é€‚é… */
        @media screen and (max-width: 768px) {
            .back-btn {
                padding: 8px 16px;
                font-size: 14px;
                top: 10px;
                left: 10px;
            }
            .toggle-container {
                top: 10px;
                right: 10px;
                gap: 5px;
            }
            .debug-toggle {
                padding: 8px 12px;
            }
            .debug-toggle label {
                font-size: 12px;
            }
            .video-panel {
                left: 10px;
                top: auto;
                bottom: 10px;
                transform: none;
            }
            #videoCanvas {
                width: 200px;
                height: 112px;
            }
            .debug-panel {
                top: 110px;
                right: 10px;
                min-width: 180px;
                max-height: 40vh;
                padding: 10px;
            }
            .game-over-text {
                font-size: 32px;
            }
            .game-over-stats {
                font-size: 18px;
            }
            .home-btn, .restart-btn {
                padding: 12px 30px;
                font-size: 16px;
            }
        }

        @media screen and (max-height: 600px) {
            .game-over-text {
                font-size: 28px;
                margin-bottom: 10px;
            }
            .game-over-stats {
                font-size: 16px;
                margin-bottom: 15px;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">â† è¿”å›ä¸»é¡µ</a>

    <div class="toggle-container">
        <div class="debug-toggle camera-toggle">
            <label for="cameraMode">ğŸ“· é•œå¤´æ¨¡å¼</label>
            <input type="checkbox" id="cameraMode">
        </div>
        <div class="debug-toggle">
            <label for="debugMode">ğŸ› è°ƒè¯•æ¨¡å¼</label>
            <input type="checkbox" id="debugMode">
        </div>
    </div>

    <div class="debug-panel" id="debugPanel">
        <div class="debug-section">
            <div class="debug-label">
                ğŸ“Š å¸§ç‡ (FPS)
                <span class="debug-value" id="fpsValue">--</span>
            </div>
            <div class="debug-hint">ç›®æ ‡å¸§ç‡: 60 FPS</div>
        </div>

        <div class="debug-section">
            <div class="debug-label">
                ğŸ¯ æ‰‹éƒ¨çµæ•åº¦
                <span class="debug-value" id="sensitivityValue">4.0</span>
            </div>
            <input type="range" class="debug-slider" id="sensitivitySlider" min="1.0" max="6.0" step="0.1" value="4.0">
            <div class="debug-hint">1.0 = æ­£å¸¸ | 4.0 = 4å€ | 6.0 = 6å€</div>
        </div>

        <div class="debug-section">
            <div class="debug-label">
                ğŸ”¥ çƒé€Ÿå¢é•¿ç‡
                <span class="debug-value" id="speedMultiplierValue">1.2</span>
            </div>
            <input type="range" class="debug-slider" id="speedMultiplierSlider" min="1.0" max="2.0" step="0.05" value="1.2">
            <div class="debug-hint">æ¯æ¬¡ç¢°æŒ¡æ¿é€Ÿåº¦ Ã— N å€</div>
        </div>

        <div class="debug-section">
            <div class="debug-label">
                âš¡ æœ€å¤§çƒé€Ÿå€æ•°
                <span class="debug-value" id="maxSpeedValue">1.6</span>
            </div>
            <input type="range" class="debug-slider" id="maxSpeedSlider" min="1.0" max="3.0" step="0.1" value="1.6">
            <div class="debug-hint">çƒé€Ÿä¸Šé™ = åˆå§‹é€Ÿåº¦ Ã— N å€</div>
        </div>

        <div class="debug-section">
            <div class="debug-label">
                ğŸ­ è„¸éƒ¨è¡¨æƒ…
                <span class="debug-value" id="faceEmojiValue">ğŸ˜€</span>
            </div>
            <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                <button class="emoji-btn active" data-emoji="ğŸ˜€">ğŸ˜€</button>
                <button class="emoji-btn" data-emoji="ğŸ˜">ğŸ˜</button>
                <button class="emoji-btn" data-emoji="ğŸ¤ª">ğŸ¤ª</button>
                <button class="emoji-btn" data-emoji="ğŸ˜œ">ğŸ˜œ</button>
                <button class="emoji-btn" data-emoji="ğŸ¥³">ğŸ¥³</button>
                <button class="emoji-btn" data-emoji="ğŸ˜‚">ğŸ˜‚</button>
                <button class="emoji-btn" data-emoji="ğŸ¤¯">ğŸ¤¯</button>
                <button class="emoji-btn" data-emoji="ğŸ‘½">ğŸ‘½</button>
            </div>
            <div class="debug-hint">é€‰æ‹©è¡¨æƒ…é®è„¸</div>
        </div>

        <div class="debug-section">
            <div class="debug-label">
                ğŸ§± æ–°è¡Œç”Ÿæˆé—´éš”
                <span class="debug-value" id="newRowIntervalValue">10.0</span>
            </div>
            <input type="range" class="debug-slider" id="newRowIntervalSlider" min="3.0" max="30.0" step="0.5" value="10.0">
            <div class="debug-hint">æ¯éš” N ç§’ç”Ÿæˆæ–°ç –å—è¡Œ</div>
        </div>
    </div>

    <!-- èƒŒæ™¯éŸ³ä¹ -->
    <audio id="bgMusic" loop>
        <source src="assets/audio/ai_bgm.mp3" type="audio/mpeg">
    </audio>
    <audio id="boardSound"><source src="assets/audio/ai_board.wav" type="audio/wav"></audio>
    <audio id="bombSound"><source src="assets/audio/ai_bomb.wav" type="audio/wav"></audio>

    <!-- è§†é¢‘é¢æ¿ - å›ºå®šåœ¨å·¦ä¾§ -->
    <div class="video-panel hidden" id="videoPanel">
        <h3>ğŸ“· æ‰‹åŠ¿è¯†åˆ«</h3>
        <canvas id="videoCanvas" width="640" height="360"></canvas>
        <div class="status">
            çŠ¶æ€: <span id="status">æ­£åœ¨åˆå§‹åŒ–...</span>
        </div>
    </div>

    <div class="main-container" id="mainContainer">
        <div class="game-panel">
            <h2>ğŸ¯ å•äººçƒ­èº«èµ›</h2>

            <!-- é¡¶éƒ¨ä¿¡æ¯æ  -->
            <div class="game-header">
                <div class="header-item">
                    <div class="header-label">Score</div>
                    <div class="header-value" id="headerScore">0</div>
                </div>
                <div class="header-item avatar">
                    <div class="avatar-circle">
                        <img src="assets/images/head1.gif" alt="Avatar">
                    </div>
                </div>
                <div class="header-item">
                    <div class="header-label">Time</div>
                    <div class="header-value" id="headerTime">0:00</div>
                </div>
            </div>

            <canvas id="gameCanvas" width="400" height="500"></canvas>
        </div>
    </div>

    <div id="gameOverOverlay" class="game-over-overlay">
        <div class="game-over-text">ğŸ‰ æ­å–œé€šå…³ï¼</div>
        <div class="game-over-stats">
            æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span><br>
            æœ€é«˜Combo: <span id="maxCombo">0</span>
        </div>
        <button class="home-btn" onclick="window.location.href='index.html'">è¿”å›ä¸»é¡µ</button>
        <button class="restart-btn" onclick="restartGame()">å†ç©ä¸€æ¬¡</button>
    </div>

    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js" crossorigin="anonymous"></script>

    <script>
        // ============ æ¨¡å¼æ§åˆ¶ ============
        const cameraCheckbox = document.getElementById('cameraMode');
        const debugCheckbox = document.getElementById('debugMode');
        const videoPanel = document.getElementById('videoPanel');
        const mainContainer = document.getElementById('mainContainer');
        const debugPanel = document.getElementById('debugPanel');

        // é•œå¤´æ¨¡å¼å¼€å…³ - æ§åˆ¶æ‘„åƒå¤´çª—å£
        cameraCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                videoPanel.classList.remove('hidden');
            } else {
                videoPanel.classList.add('hidden');
            }
        });

        // è°ƒè¯•æ¨¡å¼å¼€å…³ - åªæ§åˆ¶è°ƒè¯•é¢æ¿
        debugCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                debugPanel.classList.add('visible');
            } else {
                debugPanel.classList.remove('visible');
            }
        });

        // ============ è‡ªåŠ¨ç¼©æ”¾é€‚é… ============
        function adjustScale() {
            const container = document.getElementById('mainContainer');
            if (!container) return;

            // æ¸¸æˆé¢æ¿çš„åŸå§‹å°ºå¯¸ï¼ˆæ¸¸æˆé¢æ¿å§‹ç»ˆå±…ä¸­ï¼Œé•œå¤´å’Œè°ƒè¯•é¢æ¿ç‹¬ç«‹å®šä½ï¼‰
            const gameWidth = 430;  // æ¸¸æˆé¢æ¿å®½åº¦ + padding
            const gameHeight = 620; // æ¸¸æˆé¢æ¿é«˜åº¦ + padding

            // è·å–å¯ç”¨è§†å£å°ºå¯¸ï¼ˆå‡å»ä¸€äº›è¾¹è·ï¼‰
            const viewportWidth = window.innerWidth - 40;
            const viewportHeight = window.innerHeight - 100; // ç•™å‡ºé¡¶éƒ¨æŒ‰é’®ç©ºé—´

            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼ˆå–å®½é«˜ä¸­è¾ƒå°çš„æ¯”ä¾‹ï¼Œç¡®ä¿å®Œå…¨æ˜¾ç¤ºï¼‰
            const scaleX = viewportWidth / gameWidth;
            const scaleY = viewportHeight / gameHeight;
            let scale = Math.min(scaleX, scaleY, 1); // æœ€å¤§ä¸è¶…è¿‡1ï¼ˆä¸æ”¾å¤§ï¼‰

            // æœ€å°ç¼©æ”¾é™åˆ¶ï¼Œé˜²æ­¢è¿‡å°
            scale = Math.max(scale, 0.3);

            // åº”ç”¨ç¼©æ”¾
            container.style.transform = `scale(${scale})`;

            console.log(`å±å¹•é€‚é…: ${window.innerWidth}x${window.innerHeight}, ç¼©æ”¾æ¯”ä¾‹: ${scale.toFixed(2)}`);
        }

        // ç›‘å¬çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', adjustScale);

        // ç›‘å¬å±å¹•æ–¹å‘å˜åŒ–ï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰
        window.addEventListener('orientationchange', () => {
            setTimeout(adjustScale, 100); // å»¶è¿Ÿæ‰§è¡Œï¼Œç­‰å¾…æ–¹å‘å˜åŒ–å®Œæˆ
        });

        // åˆå§‹è°ƒç”¨
        setTimeout(adjustScale, 100);

        // ============ èƒŒæ™¯éŸ³ä¹æ§åˆ¶ ============
        const bgMusic = document.getElementById('bgMusic');
        bgMusic.volume = 0.3;
        bgMusic.playbackRate = 1.0;  // åˆå§‹æ’­æ”¾é€Ÿåº¦

        // æ›´æ–°éŸ³ä¹æ’­æ”¾é€Ÿåº¦ï¼ˆä¸çƒé€ŸåŒæ­¥ï¼‰
        function updateMusicSpeed() {
            if (game.heatMode && game.balls.length > 0) {
                const normalBall = game.balls.find(b => b.type === 'normal');
                if (normalBall) {
                    const currentSpeed = Math.sqrt(normalBall.vx * normalBall.vx + normalBall.vy * normalBall.vy);
                    const speedMultiplier = currentSpeed / CONFIG.ballSpeed;
                    // éŸ³ä¹é€Ÿåº¦ä¸çƒé€Ÿå€æ•°ä¸€è‡´ï¼Œä½†é™åˆ¶åœ¨åˆç†èŒƒå›´å†…ï¼ˆ0.5-2.0ï¼‰
                    bgMusic.playbackRate = Math.min(Math.max(speedMultiplier, 0.5), 2.0);
                }
            } else {
                // éçƒ­åŠ›æ¨¡å¼ï¼Œæ¢å¤æ­£å¸¸é€Ÿåº¦
                bgMusic.playbackRate = 1.0;
            }
        }

        // ============ éŸ³æ•ˆæ§åˆ¶ï¼ˆä½¿ç”¨ Web Audio APIï¼ŒiOS å…¼å®¹ï¼‰============

        // Web Audio API ä¸Šä¸‹æ–‡ï¼ˆåªéœ€è§£é”ä¸€æ¬¡ï¼‰
        let audioContext = null;
        let audioBuffers = {
            board: null,
            bomb: null
        };
        let audioLoaded = false;
        let audioUnlocked = false;

        // éŸ³æ•ˆçš„ç›®æ ‡éŸ³é‡
        const BOARD_SOUND_VOLUME = 0.3;
        const BOMB_SOUND_VOLUME = 0.5;

        // åˆå§‹åŒ– Web Audio API
        async function initWebAudio() {
            try {
                // åˆ›å»º AudioContextï¼ˆå…¼å®¹æ—§ç‰ˆ Safariï¼‰
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContextClass();

                // åŠ è½½éŸ³é¢‘æ–‡ä»¶ä¸º buffer
                const [boardBuffer, bombBuffer] = await Promise.all([
                    loadAudioBuffer('assets/audio/ai_board.wav'),
                    loadAudioBuffer('assets/audio/ai_bomb.wav')
                ]);

                audioBuffers.board = boardBuffer;
                audioBuffers.bomb = bombBuffer;
                audioLoaded = true;
                console.log('âœ“ éŸ³æ•ˆåŠ è½½å®Œæˆ');
            } catch (err) {
                console.error('Web Audio åˆå§‹åŒ–å¤±è´¥:', err);
            }
        }

        // åŠ è½½å•ä¸ªéŸ³é¢‘æ–‡ä»¶ä¸º AudioBuffer
        async function loadAudioBuffer(url) {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            return await audioContext.decodeAudioData(arrayBuffer);
        }

        // è§£é”éŸ³é¢‘ï¼ˆiOS å¿…é¡»åœ¨ç”¨æˆ·äº¤äº’æ—¶è°ƒç”¨ï¼‰
        function unlockAudio() {
            if (audioUnlocked) return;

            // è§£é”èƒŒæ™¯éŸ³ä¹
            bgMusic.play().then(() => {
                console.log('âœ“ èƒŒæ™¯éŸ³ä¹å¼€å§‹æ’­æ”¾');
            }).catch(err => {
                console.log('èƒŒæ™¯éŸ³ä¹ç­‰å¾…è§£é”...');
            });

            // è§£é” Web Audio API
            if (audioContext) {
                // å¦‚æœè¢«æš‚åœï¼Œæ¢å¤å®ƒ
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('âœ“ AudioContext å·²æ¢å¤');
                    });
                }

                // å¦‚æœéŸ³é¢‘å·²åŠ è½½ï¼Œæ’­æ”¾ä¸€ä¸ªé™éŸ³çš„çŸ­éŸ³æ¥ç¡®ä¿å®Œå…¨è§£é”
                if (audioLoaded && audioBuffers.board) {
                    try {
                        const silentSource = audioContext.createBufferSource();
                        const silentGain = audioContext.createGain();
                        silentGain.gain.value = 0;  // é™éŸ³
                        silentSource.buffer = audioBuffers.board;
                        silentSource.connect(silentGain);
                        silentGain.connect(audioContext.destination);
                        silentSource.start(0);
                        silentSource.stop(audioContext.currentTime + 0.001);
                    } catch (e) {
                        console.log('é™éŸ³è§£é”å¤±è´¥:', e);
                    }
                }

                // åªè¦ AudioContext å­˜åœ¨ä¸”çŠ¶æ€æ­£å¸¸ï¼Œå°±æ ‡è®°ä¸ºå·²è§£é”
                if (audioContext.state === 'running' || audioLoaded) {
                    audioUnlocked = true;
                    console.log('âœ“ éŸ³æ•ˆå·²è§£é”ï¼ŒçŠ¶æ€:', audioContext.state);

                    // è§£é”æˆåŠŸï¼Œç§»é™¤ç›‘å¬å™¨
                    document.removeEventListener('click', unlockAudio);
                    document.removeEventListener('touchstart', unlockAudio);
                    document.removeEventListener('touchend', unlockAudio);
                    document.removeEventListener('keydown', unlockAudio);
                }
            }
        }

        // ç›‘å¬å¤šç§ç”¨æˆ·äº¤äº’äº‹ä»¶æ¥è§£é”éŸ³é¢‘
        document.addEventListener('click', unlockAudio);
        document.addEventListener('touchstart', unlockAudio);
        document.addEventListener('touchend', unlockAudio);
        document.addEventListener('keydown', unlockAudio);

        // å¼€å§‹åŠ è½½éŸ³é¢‘
        initWebAudio();

        // æ’­æ”¾éŸ³æ•ˆï¼ˆä½¿ç”¨ Web Audio APIï¼‰
        function playSound(buffer, volume) {
            // æ¡Œé¢æµè§ˆå™¨ï¼šå³ä½¿æ²¡æœ‰ç”¨æˆ·äº¤äº’ä¹Ÿå°è¯•æ’­æ”¾
            if (!audioContext || !buffer) return;

            // å¦‚æœè¿˜æ²¡è§£é”ï¼Œå°è¯•æ¢å¤ AudioContext
            if (!audioUnlocked && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            try {
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                gainNode.gain.value = volume;

                source.buffer = buffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);
            } catch (err) {
                console.log('éŸ³æ•ˆæ’­æ”¾å¤±è´¥:', err);
            }
        }

        // æ’­æ”¾æŒ¡æ¿éŸ³æ•ˆ
        function playBoardSound() {
            playSound(audioBuffers.board, BOARD_SOUND_VOLUME);
        }

        // æ’­æ”¾ç‚¸å¼¹éŸ³æ•ˆ
        function playBombSound() {
            playSound(audioBuffers.bomb, BOMB_SOUND_VOLUME);
        }

        // ============ æ¸¸æˆé…ç½® ============
        const CONFIG = {
            brickRows: 8,
            brickCols: 8,
            brickWidth: 43,
            brickHeight: 18,
            brickPadding: 4,
            brickOffsetTop: 50,
            brickOffsetLeft: 10,
            paddleWidth: 80,
            paddleHeight: 12,
            ballSpeed: 5,
            ballRadius: 6,
            sensitivity: 4.0,
            speedMultiplier: 1.2,  // çƒ­åŠ›æ¨¡å¼ä¸‹çƒé€Ÿå¢é•¿ç‡
            maxSpeedMultiplier: 1.6,  // æœ€å¤§çƒé€Ÿå€æ•°
            newRowInterval: 10.0,  // æ–°è¡Œç”Ÿæˆæ—¶é—´é—´éš”ï¼ˆç§’ï¼‰- æ”¹ä¸º10ç§’ï¼ˆé€Ÿåº¦å‡åŠï¼‰
            deathLine: 17,  // è§¦åº•çº¿ï¼šç¬¬18è¡Œï¼ˆç´¢å¼•17ï¼Œä»0å¼€å§‹ï¼‰
            gameTimeLimit: 60  // æ¸¸æˆæ—¶é—´é™åˆ¶ï¼ˆç§’ï¼‰
        };

        // ============ è°ƒè¯•æ§åˆ¶é¢æ¿äº‹ä»¶ ============
        const sensitivitySlider = document.getElementById('sensitivitySlider');
        const sensitivityValue = document.getElementById('sensitivityValue');
        const speedMultiplierSlider = document.getElementById('speedMultiplierSlider');
        const speedMultiplierValue = document.getElementById('speedMultiplierValue');
        const maxSpeedSlider = document.getElementById('maxSpeedSlider');
        const maxSpeedValue = document.getElementById('maxSpeedValue');

        sensitivitySlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            CONFIG.sensitivity = value;
            sensitivityValue.textContent = value.toFixed(1);
        });

        speedMultiplierSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            CONFIG.speedMultiplier = value;
            speedMultiplierValue.textContent = value.toFixed(2);
        });

        maxSpeedSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            CONFIG.maxSpeedMultiplier = value;
            maxSpeedValue.textContent = value.toFixed(1);
        });

        const newRowIntervalSlider = document.getElementById('newRowIntervalSlider');
        const newRowIntervalValue = document.getElementById('newRowIntervalValue');

        newRowIntervalSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            CONFIG.newRowInterval = value;
            newRowIntervalValue.textContent = value.toFixed(1) + 's';
        });

        // ============ è¡¨æƒ…é®è„¸æ§åˆ¶ ============
        let selectedEmoji = 'ğŸ˜€';
        const faceEmojiValue = document.getElementById('faceEmojiValue');
        const emojiBtns = document.querySelectorAll('.emoji-btn');

        emojiBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                emojiBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedEmoji = btn.dataset.emoji;
                faceEmojiValue.textContent = selectedEmoji;
            });
        });

        // ============ æ¸¸æˆçŠ¶æ€ ============
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const game = {
            paddle: {
                x: canvas.width / 2,
                y: canvas.height - 40,
                width: CONFIG.paddleWidth,
                height: CONFIG.paddleHeight,
                vx: 0
            },
            balls: [],
            bricks: [],
            particles: [],  // ç –å—ç¢ç‰‡ç²’å­
            score: 0,
            heat: 0,
            heatMode: false,
            combo: 0,
            maxCombo: 0,
            comboDisplay: {
                show: false,
                value: 0,
                startTime: 0
            },
            hand: {
                detected: false,
                isOpen: false,
                x: 0.5,
                y: 0.5,
                closedFrames: 0
            },
            startTime: 0,  // æ¸¸æˆå¼€å§‹æ—¶é—´
            gameTime: 60,   // å‰©ä½™æ—¶é—´ï¼ˆç§’ï¼‰- å€’è®¡æ—¶ä»60å¼€å§‹
            nextRowTime: 0,  // ä¸‹ä¸€è¡Œç –å—ç”Ÿæˆæ—¶é—´
            brickTransition: {  // ç –å—è¿‡æ¸¡åŠ¨ç”»
                active: false,
                startTime: 0,
                duration: 300  // 300msè¿‡æ¸¡æ—¶é—´
            },
            backgroundFlash: {  // èƒŒæ™¯æ‰©æ•£æ•ˆæœ
                active: false,
                startTime: 0,
                duration: 200,  // æŒç»­200ms
                colors: [  // ä½é¥±å’Œåº¦ç°è°ƒè‰²æ¿ï¼ˆé¿å¼€ç –å—/çƒ/æŒ¡æ¿é¢œè‰²ï¼‰
                    '#2d4654', // æ·±è“ç°
                    '#3d2f4d', // æ·±ç´«ç°
                    '#2f4f4f', // æ·±é’ç°
                    '#4a4453', // æ·±ç´«è¤
                    '#3b4d4b', // æ·±ç»¿ç°
                    '#4d3f3f', // æ·±è¤ç°
                    '#2f3e4e', // æ·±é’¢è“
                    '#3d3f4d'  // æ·±è“ç´«ç°
                ],
                currentColorIndex: 0,
                targetColor: '#0f0f23',  // ç›®æ ‡é¢œè‰²
                currentBgColor: '#0f0f23'  // å½“å‰èƒŒæ™¯è‰²ï¼ˆæŒä¹…çŠ¶æ€ï¼‰
            }
        };

        let gameOver = false;

        // ============ å¸§ç‡æ§åˆ¶ï¼ˆDelta Timeï¼‰ ============
        let lastFrameTime = 0;
        let deltaTime = 0;
        const TARGET_FPS = 60;
        const TARGET_FRAME_TIME = 1000 / TARGET_FPS; // 16.67ms

        // FPS è®¡ç®—
        let frameCount = 0;
        let fpsLastTime = 0;
        let currentFPS = 0;

        // ============ åˆå§‹åŒ–ç –å— ============
        function initBricks() {
            game.bricks = [];
            const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#a855f7', '#ec4899', '#f43f5e'];

            // å¿ƒå½¢å›¾æ¡ˆ (8x8 ç½‘æ ¼ï¼Œ1=ç –å—ï¼Œ0=ç©ºä½)
            const heartPattern = [
                [0, 1, 1, 0, 0, 1, 1, 0],  // é¡¶éƒ¨ä¸¤ä¸ªå¼§
                [1, 1, 1, 1, 1, 1, 1, 1],  // å¡«å……
                [1, 1, 1, 1, 1, 1, 1, 1],  // å¡«å……
                [1, 1, 1, 1, 1, 1, 1, 1],  // ä¸­éƒ¨æœ€å®½
                [0, 1, 1, 1, 1, 1, 1, 0],  // æ”¶çª„
                [0, 0, 1, 1, 1, 1, 0, 0],  // ç»§ç»­æ”¶çª„
                [0, 0, 0, 1, 1, 0, 0, 0],  // å°–ç«¯
                [0, 0, 0, 0, 0, 0, 0, 0]   // åº•éƒ¨ç©ºè¡Œ
            ];

            // ç‚¸å¼¹ä½ç½®ï¼ˆåœ¨æœ‰ç –å—çš„ä½ç½®ä¸­éšæœºé€‰æ‹©4ä¸ªï¼‰
            const bombPositions = new Set();
            const availablePositions = [];

            // æ”¶é›†æ‰€æœ‰æœ‰ç –å—çš„ä½ç½®
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (heartPattern[row][col] === 1) {
                        availablePositions.push(`${row},${col}`);
                    }
                }
            }

            // éšæœºé€‰æ‹©4ä¸ªä½ç½®ä½œä¸ºç‚¸å¼¹
            const shuffled = availablePositions.sort(() => Math.random() - 0.5);
            for (let i = 0; i < Math.min(4, shuffled.length); i++) {
                bombPositions.add(shuffled[i]);
            }

            // ç”Ÿæˆç –å—
            for (let row = 0; row < CONFIG.brickRows; row++) {
                for (let col = 0; col < CONFIG.brickCols; col++) {
                    // æ£€æŸ¥æ˜¯å¦åº”è¯¥ç”Ÿæˆç –å—
                    if (heartPattern[row][col] === 0) {
                        continue;  // è·³è¿‡ç©ºä½
                    }

                    const isBomb = bombPositions.has(`${row},${col}`);
                    const brickColor = colors[row % colors.length];

                    game.bricks.push({
                        x: CONFIG.brickOffsetLeft + col * (CONFIG.brickWidth + CONFIG.brickPadding),
                        y: CONFIG.brickOffsetTop + row * (CONFIG.brickHeight + CONFIG.brickPadding),
                        targetY: CONFIG.brickOffsetTop + row * (CONFIG.brickHeight + CONFIG.brickPadding),
                        width: CONFIG.brickWidth,
                        height: CONFIG.brickHeight,
                        color: brickColor,
                        alive: true,
                        breaking: false,
                        breakStartTime: 0,
                        type: isBomb ? 'bomb' : 'normal',
                        row: row,
                        col: col
                    });
                }
            }
        }

        // æ·»åŠ æ–°çš„ä¸€è¡Œç –å—
        function addNewBrickRow() {
            const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#a855f7', '#ec4899', '#f43f5e'];

            // å°†æ‰€æœ‰ç°æœ‰ç –å—å‘ä¸‹ç§»åŠ¨ä¸€è¡Œï¼Œå¹¶æ›´æ–°rowç´¢å¼•
            const rowHeight = CONFIG.brickHeight + CONFIG.brickPadding;
            for (const brick of game.bricks) {
                brick.targetY = brick.y + rowHeight;
                brick.row++;  // è¡Œç´¢å¼•+1
            }

            // åœ¨é¡¶éƒ¨ç”Ÿæˆæ–°çš„ä¸€è¡Œ
            const randomColor = colors[Math.floor(Math.random() * colors.length)];

            // éšæœºé€‰æ‹©ä¸€ä¸ªä½ç½®ä½œä¸ºç©ºä½
            const emptyCol = Math.floor(Math.random() * CONFIG.brickCols);

            // éšæœºé€‰æ‹©ä¸€ä¸ªä½ç½®ä½œä¸ºç‚¸å¼¹ï¼ˆç¡®ä¿ä¸æ˜¯ç©ºä½ï¼‰
            let bombCol;
            do {
                bombCol = Math.floor(Math.random() * CONFIG.brickCols);
            } while (bombCol === emptyCol);  // å¦‚æœå’Œç©ºä½é‡å¤ï¼Œé‡æ–°é€‰æ‹©

            for (let col = 0; col < CONFIG.brickCols; col++) {
                // è·³è¿‡ç©ºä½
                if (col === emptyCol) {
                    continue;
                }

                const isBomb = (col === bombCol);

                game.bricks.push({
                    x: CONFIG.brickOffsetLeft + col * (CONFIG.brickWidth + CONFIG.brickPadding),
                    y: CONFIG.brickOffsetTop - rowHeight,  // ä»ä¸Šæ–¹å¼€å§‹
                    targetY: CONFIG.brickOffsetTop,
                    width: CONFIG.brickWidth,
                    height: CONFIG.brickHeight,
                    color: randomColor,
                    alive: true,
                    breaking: false,
                    breakStartTime: 0,
                    type: isBomb ? 'bomb' : 'normal',
                    row: 0,  // æ–°ç”Ÿæˆçš„åœ¨ç¬¬0è¡Œ
                    col: col
                });
            }

            // å¯åŠ¨è¿‡æ¸¡åŠ¨ç”»
            game.brickTransition.active = true;
            game.brickTransition.startTime = Date.now();

            // è®¾ç½®ä¸‹ä¸€æ¬¡ç”Ÿæˆæ—¶é—´ï¼ˆä½¿ç”¨ç»è¿‡çš„æ—¶é—´ï¼‰
            const elapsedTime = Math.floor((Date.now() - game.startTime) / 1000);
            game.nextRowTime = elapsedTime + CONFIG.newRowInterval;
        }

        // ç”Ÿæˆç –å—ç¢ç‰‡ï¼ˆé©¬é‡Œå¥¥é£æ ¼ï¼‰
        function createBrickParticles(brick) {
            const particleCount = 8;  // 8ä¸ªç¢ç‰‡ï¼ˆæ›´å¤šï¼‰
            const centerX = brick.x + brick.width / 2;
            const centerY = brick.y + brick.height / 2 + 3;  // ç¨å¾®ä¸‹ç§»3px
            const particleSize = 8;  // ç¢ç‰‡å¤§å°ï¼š4â†’8ï¼ˆç¿»å€ï¼‰

            for (let i = 0; i < particleCount; i++) {
                // ç”Ÿæˆä¸åŒæ–¹å‘çš„ç¢ç‰‡ï¼Œä½†å‡å°‘æ°´å¹³æ‰©æ•£
                const angle = (Math.PI * 2 / particleCount) * i + Math.random() * 0.3;
                const speed = 2 + Math.random() * 1.5;  // æ°´å¹³é€Ÿåº¦å‡å°ï¼š3-5 â†’ 2-3.5

                game.particles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 6,  // å‘ä¸Šé€Ÿåº¦å¢åŠ ï¼š-3 â†’ -6ï¼ˆæ›´çŒ›çƒˆï¼‰
                    size: particleSize,
                    color: brick.color,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.4,  // æ—‹è½¬æ›´å¿«ï¼š0.3 â†’ 0.4
                    gravity: 0.4,  // é‡åŠ›å¢åŠ ï¼š0.3 â†’ 0.4ï¼ˆæ›´å¿«è½ä¸‹ï¼‰
                    life: 1.0,  // ç”Ÿå‘½å€¼ï¼ˆ1.0åˆ°0ï¼‰
                    fadeSpeed: 0.015  // æ·¡å‡ºé€Ÿåº¦å‡æ…¢ï¼š0.02 â†’ 0.015ï¼ˆæŒç»­æ›´ä¹…ï¼‰
                });
            }
        }

        // è®¡ç®—åŠ åˆ†ï¼ˆè€ƒè™‘çƒ­åŠ›æ¨¡å¼å’ŒComboï¼‰
        function calculateScore() {
            const baseScore = 10;
            if (game.heatMode && game.combo > 0) {
                return baseScore + game.combo;  // åŸºç¡€åˆ† + Comboé¢å¤–åˆ†
            }
            return baseScore;  // ä»…åŸºç¡€åˆ†
        }

        // ç‚¸å¼¹çˆ†ç‚¸ï¼šå¼•çˆ†å‘¨å›´ä¸€åœˆç –å—
        function explodeBomb(bombBrick) {
            const bombRow = bombBrick.row;
            const bombCol = bombBrick.col;

            // ç”Ÿæˆçˆ†ç‚¸ç²’å­ï¼ˆæ›´å¤šæ›´ç‚«ï¼‰
            createBombExplosionParticles(bombBrick);

            // éå†å‘¨å›´3x3èŒƒå›´çš„ç –å—
            for (const brick of game.bricks) {
                if (!brick.alive || brick.breaking) continue;
                if (brick === bombBrick) continue;

                const rowDiff = Math.abs(brick.row - bombRow);
                const colDiff = Math.abs(brick.col - bombCol);

                // å‘¨å›´ä¸€åœˆï¼ˆ3x3èŒƒå›´ï¼Œä¸åŒ…æ‹¬è‡ªå·±ï¼‰
                if (rowDiff <= 1 && colDiff <= 1) {
                    // ç”Ÿæˆç¢ç‰‡
                    createBrickParticles(brick);

                    // æ ‡è®°ä¸ºç ´ç¢
                    brick.breaking = true;
                    brick.breakStartTime = Date.now();

                    // å¢åŠ åˆ†æ•°ï¼ˆä½¿ç”¨çƒ­åŠ›æ¨¡å¼åŠ æˆï¼‰
                    game.score += calculateScore();
                }
            }

            // æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
            playBombSound();
        }

        // ç”Ÿæˆç‚¸å¼¹çˆ†ç‚¸ç²’å­ï¼ˆæ›´ç‚«é…·ï¼‰
        function createBombExplosionParticles(brick) {
            const particleCount = 20;  // æ›´å¤šç²’å­
            const centerX = brick.x + brick.width / 2;
            const centerY = brick.y + brick.height / 2;

            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 / particleCount) * i + Math.random() * 0.2;
                const speed = 3 + Math.random() * 3;  // æ›´å¿«çš„é€Ÿåº¦

                game.particles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 4,
                    size: 6 + Math.random() * 4,  // éšæœºå¤§å°6-10
                    color: i % 3 === 0 ? '#ff6600' : (i % 3 === 1 ? '#ffaa00' : '#ff0000'),  // æ©™çº¢é»„äº¤æ›¿
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.5,
                    gravity: 0.35,
                    life: 1.0,
                    fadeSpeed: 0.012  // æŒç»­æ›´ä¹…
                });
            }
        }



        // ============ æ‰‹åŠ¿è¯†åˆ« ============
        function isHandOpen(landmarks) {
            const fingerTips = [8, 12, 16, 20];
            const fingerPIPs = [6, 10, 14, 18];
            let extendedFingers = 0;
            for (let i = 0; i < 4; i++) {
                if (landmarks[fingerTips[i]].y < landmarks[fingerPIPs[i]].y) {
                    extendedFingers++;
                }
            }
            return extendedFingers >= 3;
        }

        function getPalmCenter(landmarks) {
            return {
                x: (landmarks[0].x + landmarks[9].x) / 2,
                y: (landmarks[0].y + landmarks[9].y) / 2
            };
        }

        // ============ MediaPipe æ‰‹åŠ¿æ£€æµ‹ ============
        const videoCanvas = document.getElementById('videoCanvas');
        const videoCtx = videoCanvas.getContext('2d');

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        // ============ MediaPipe äººè„¸æ£€æµ‹ ============
        let faceDetection = null;
        let detectedFaces = [];

        function initFaceDetection() {
            try {
                faceDetection = new FaceDetection({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`
                });

                faceDetection.setOptions({
                    model: 'short',
                    minDetectionConfidence: 0.5
                });

                faceDetection.onResults((results) => {
                    detectedFaces = results.detections || [];
                });

                console.log('âœ“ äººè„¸æ£€æµ‹å·²å¯ç”¨');
            } catch (error) {
                console.error('äººè„¸æ£€æµ‹åˆå§‹åŒ–å¤±è´¥:', error);
                faceDetection = null;
            }
        }

        setTimeout(initFaceDetection, 1000);

        hands.onResults(onResults);

        function onResults(results) {
            // é•œå¤´æ¨¡å¼å¼€å¯æ—¶ç»˜åˆ¶æ‘„åƒå¤´ç”»é¢
            if (cameraCheckbox.checked) {
                videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
                videoCtx.drawImage(results.image, 0, 0, videoCanvas.width, videoCanvas.height);

                // å…ˆç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹ï¼ˆåœ¨åº•å±‚ï¼‰
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    drawHandLandmarks(results.multiHandLandmarks[0]);
                }

                // åç»˜åˆ¶è¡¨æƒ…é®è„¸ï¼ˆåœ¨é¡¶å±‚ï¼Œè¦†ç›–äººè„¸ï¼‰
                if (detectedFaces.length > 0) {
                    detectedFaces.forEach(detection => {
                        const bbox = detection.boundingBox;
                        const x = bbox.xCenter * videoCanvas.width;
                        const y = bbox.yCenter * videoCanvas.height;
                        const width = bbox.width * videoCanvas.width;
                        const height = bbox.height * videoCanvas.height;

                        // ç»˜åˆ¶è¡¨æƒ…ï¼ˆæ”¾å¤§1.5å€å®Œå…¨é®æŒ¡è„¸éƒ¨ï¼‰
                        const emojiSize = Math.max(width, height) * 1.5;
                        videoCtx.font = `${emojiSize}px Arial`;
                        videoCtx.textAlign = 'center';
                        videoCtx.textBaseline = 'middle';
                        videoCtx.fillText(selectedEmoji, x, y);
                    });
                }

                // æ˜¾ç¤ºæ£€æµ‹çŠ¶æ€
                videoCtx.fillStyle = '#4ade80';
                videoCtx.font = '12px Arial';
                videoCtx.textAlign = 'left';
                videoCtx.fillText(`äººè„¸: ${detectedFaces.length}`, 10, 20);
            }

            // å¼‚æ­¥å‘é€åˆ°äººè„¸æ£€æµ‹
            if (faceDetection) {
                faceDetection.send({image: results.image}).catch(err => {
                    console.log('äººè„¸æ£€æµ‹é”™è¯¯ï¼ˆä¸å½±å“æ¸¸æˆï¼‰:', err);
                });
            }

            game.hand.detected = false;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const palmCenter = getPalmCenter(landmarks);
                const isOpen = isHandOpen(landmarks);

                game.hand.detected = true;
                game.hand.isOpen = isOpen;
                game.hand.x = 1 - palmCenter.x; // é•œåƒ

                // é˜²æŠ–ï¼šæ¡æ‹³â†’å¼ å¼€å‘å°„çƒï¼ˆä»…åœ¨æ²¡æœ‰çƒæ—¶æ‰èƒ½å‘å°„ï¼‰
                if (!isOpen) {
                    game.hand.closedFrames++;
                } else {
                    if (game.hand.closedFrames >= 3 && game.balls.length === 0) {
                        launchBall();
                    }
                    game.hand.closedFrames = 0;
                }
            }
        }

        function drawHandLandmarks(landmarks) {
            const connections = [
                [0,1],[1,2],[2,3],[3,4],
                [0,5],[5,6],[6,7],[7,8],
                [0,9],[9,10],[10,11],[11,12],
                [0,13],[13,14],[14,15],[15,16],
                [0,17],[17,18],[18,19],[19,20],
                [5,9],[9,13],[13,17]
            ];

            videoCtx.strokeStyle = '#56ab2f';
            videoCtx.lineWidth = 2;

            for (const [i, j] of connections) {
                videoCtx.beginPath();
                videoCtx.moveTo(landmarks[i].x * videoCanvas.width, landmarks[i].y * videoCanvas.height);
                videoCtx.lineTo(landmarks[j].x * videoCanvas.width, landmarks[j].y * videoCanvas.height);
                videoCtx.stroke();
            }

            for (const point of landmarks) {
                videoCtx.beginPath();
                videoCtx.arc(point.x * videoCanvas.width, point.y * videoCanvas.height, 4, 0, 2 * Math.PI);
                videoCtx.fillStyle = '#56ab2f';
                videoCtx.fill();
            }
        }

        // ============ æ¸¸æˆé€»è¾‘ ============
        function launchBall() {
            if (gameOver) return;

            // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡å‘çƒï¼Œè®°å½•å¼€å§‹æ—¶é—´
            if (game.balls.length === 0 && game.bricks.every(b => b.alive)) {
                game.startTime = Date.now();
                game.nextRowTime = CONFIG.newRowInterval;  // è®¾ç½®ç¬¬ä¸€æ¬¡æ–°è¡Œç”Ÿæˆæ—¶é—´
            }

            // å‘å°„æ–°çƒæ—¶é€€å‡ºçƒ­åŠ›æ¨¡å¼ï¼Œè§¦å‘æ·±è“è‰²æ‰©æ•£
            if (game.heatMode) {
                game.backgroundFlash.active = true;
                game.backgroundFlash.startTime = Date.now();
                game.backgroundFlash.targetColor = '#0f0f23';  // å›åˆ°æ·±è“è‰²
            }

            game.heat = 0;
            game.heatMode = false;
            game.combo = 0;
            game.balls = [];

            const speed = CONFIG.ballSpeed;
            game.balls.push({
                x: game.paddle.x,
                y: game.paddle.y - 15,
                vx: (Math.random() - 0.5) * 2,
                vy: -speed,
                type: 'normal',
                trail: []  // æ‹–å°¾ä½ç½®è®°å½•
            });
        }

        function updateGame(dt = 1) {
            if (gameOver) return;

            // ç¡®ä¿ dt æœ‰æ•ˆ
            if (!dt || dt <= 0) dt = 1;

            // æ›´æ–°æ¸¸æˆæ—¶é—´ï¼ˆå€’è®¡æ—¶ï¼‰
            if (game.startTime > 0) {
                const elapsedTime = Math.floor((Date.now() - game.startTime) / 1000);
                game.gameTime = Math.max(0, CONFIG.gameTimeLimit - elapsedTime);  // å€’è®¡æ—¶

                // æ£€æŸ¥æ—¶é—´æ˜¯å¦ç”¨å®Œ
                if (game.gameTime <= 0 && !gameOver) {
                    gameOver = true;
                    showGameOver('æ—¶é—´åˆ°ï¼æ¸¸æˆç»“æŸï¼');
                }

                // æ£€æŸ¥æ˜¯å¦éœ€è¦ç”Ÿæˆæ–°è¡Œï¼ˆä½¿ç”¨ç»è¿‡çš„æ—¶é—´ï¼‰
                if (elapsedTime >= game.nextRowTime) {
                    addNewBrickRow();
                }
            }

            // æ›´æ–°éŸ³ä¹æ’­æ”¾é€Ÿåº¦ï¼ˆä¸çƒé€ŸåŒæ­¥ï¼‰
            updateMusicSpeed();

            // æ›´æ–°ç –å—è¿‡æ¸¡åŠ¨ç”»
            if (game.brickTransition.active) {
                const elapsed = Date.now() - game.brickTransition.startTime;
                const progress = Math.min(elapsed / game.brickTransition.duration, 1);

                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°ï¼ˆeaseOutCubicï¼‰
                const easeProgress = 1 - Math.pow(1 - progress, 3);

                for (const brick of game.bricks) {
                    if (brick.targetY !== undefined) {
                        const startY = brick.targetY - (CONFIG.brickHeight + CONFIG.brickPadding);
                        brick.y = startY + (brick.targetY - startY) * easeProgress;
                    }
                }

                if (progress >= 1) {
                    game.brickTransition.active = false;
                    // è¿‡æ¸¡ç»“æŸï¼Œç¡®ä¿æ‰€æœ‰ç –å—åˆ°è¾¾ç›®æ ‡ä½ç½®
                    for (const brick of game.bricks) {
                        if (brick.targetY !== undefined) {
                            brick.y = brick.targetY;
                        }
                    }
                }
            }

            // æ›´æ–°ç –å—ç ´ç¢çŠ¶æ€
            const now = Date.now();
            for (const brick of game.bricks) {
                if (brick.breaking && now - brick.breakStartTime > 60) {
                    brick.alive = false;
                }
            }

            // æ›´æ–°ç²’å­ï¼ˆç –å—ç¢ç‰‡ï¼‰
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];

                // æ›´æ–°ä½ç½®ï¼ˆä½¿ç”¨ delta timeï¼‰
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // åº”ç”¨é‡åŠ›
                p.vy += p.gravity * dt;

                // æ›´æ–°æ—‹è½¬
                p.rotation += p.rotationSpeed * dt;

                // æ·¡å‡º
                p.life -= p.fadeSpeed * dt;

                // ç§»é™¤æ¶ˆå¤±çš„ç²’å­
                if (p.life <= 0 || p.y > canvas.height) {
                    game.particles.splice(i, 1);
                }
            }

            // æ‰‹æ§åˆ¶æŒ¡æ¿ï¼ˆåªæ§åˆ¶ç§»åŠ¨ï¼Œä¸æ§åˆ¶æ—‹è½¬ï¼‰
            if (game.hand.detected) {
                const centerX = canvas.width / 2;
                const handOffset = game.hand.x - 0.5;
                const targetX = centerX + handOffset * CONFIG.sensitivity * canvas.width;

                const springStrength = 0.15;
                const damping = 0.8;

                const acceleration = (targetX - game.paddle.x) * springStrength;
                game.paddle.vx += acceleration * dt;
                game.paddle.vx *= Math.pow(damping, dt);
                game.paddle.x += game.paddle.vx * dt;

                game.paddle.x = Math.max(game.paddle.width/2,
                                Math.min(canvas.width - game.paddle.width/2, game.paddle.x));
            }

            // æ›´æ–°çƒ
            for (let i = game.balls.length - 1; i >= 0; i--) {
                const ball = game.balls[i];

                // è®°å½•çƒçš„è½¨è¿¹ï¼ˆç”¨äºæ‹–å°¾ï¼‰
                if (!ball.trail) ball.trail = [];
                ball.trail.push({ x: ball.x, y: ball.y });
                // ä¿æŒæ‹–å°¾é•¿åº¦åœ¨8-12ä¸ªç‚¹ä¹‹é—´ï¼ˆæ ¹æ®é€Ÿåº¦åŠ¨æ€è°ƒæ•´ï¼‰
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                const trailLength = Math.floor(8 + (speed / CONFIG.ballSpeed) * 4);
                if (ball.trail.length > trailLength) {
                    ball.trail.shift();
                }

                ball.x += ball.vx * dt;
                ball.y += ball.vy * dt;

                // å¢™å£ç¢°æ’
                if (ball.x - CONFIG.ballRadius < 0 || ball.x + CONFIG.ballRadius > canvas.width) {
                    ball.vx = -ball.vx;
                    ball.x = Math.max(CONFIG.ballRadius, Math.min(canvas.width - CONFIG.ballRadius, ball.x));
                }
                if (ball.y - CONFIG.ballRadius < 0) {
                    ball.vy = -ball.vy;
                    ball.y = CONFIG.ballRadius;
                }

                // çƒè½å‡ºåº•éƒ¨
                if (ball.y > canvas.height + 30) {
                    // é€€å‡ºçƒ­åŠ›æ¨¡å¼æ—¶ï¼Œè§¦å‘æ·±è“è‰²æ‰©æ•£
                    if (game.heatMode) {
                        game.backgroundFlash.active = true;
                        game.backgroundFlash.startTime = Date.now();
                        game.backgroundFlash.targetColor = '#0f0f23';  // å›åˆ°æ·±è“è‰²
                    }

                    game.heat = 0;
                    game.heatMode = false;
                    game.combo = 0;
                    game.balls.splice(i, 1);
                    continue;
                }

                // æŒ¡æ¿ç¢°æ’
                if (checkPaddleCollision(ball)) {
                    let speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    const hitPos = (ball.x - game.paddle.x) / (game.paddle.width / 2);
                    const bounceAngle = -Math.PI/2 + hitPos * 0.5;

                    // çƒ­åŠ›æ¨¡å¼ä¸‹é€Ÿåº¦ç´¯ä¹˜
                    if (game.heatMode) {
                        speed *= CONFIG.speedMultiplier;
                        const maxSpeed = CONFIG.ballSpeed * CONFIG.maxSpeedMultiplier;
                        if (speed > maxSpeed) speed = maxSpeed;
                    }

                    ball.vx = Math.cos(bounceAngle) * speed;
                    ball.vy = Math.sin(bounceAngle) * speed;
                    if (ball.vy > 0) ball.vy = -ball.vy;

                    ball.y = game.paddle.y - CONFIG.ballRadius - game.paddle.height/2 - 1;

                    playBoardSound();

                    // å¢åŠ comboå’Œçƒ­åŠ›å€¼
                    game.combo++;
                    if (game.combo > game.maxCombo) game.maxCombo = game.combo;

                    if (game.combo > 3) {
                        game.comboDisplay.show = true;
                        game.comboDisplay.value = game.combo;
                        game.comboDisplay.startTime = Date.now();

                        // çƒ­åŠ›æ¨¡å¼ä¸‹ï¼ŒComboå¢åŠ æ—¶è§¦å‘èƒŒæ™¯åˆ‡æ¢
                        if (game.heatMode) {
                            game.backgroundFlash.active = true;
                            game.backgroundFlash.startTime = Date.now();
                            // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªé¢œè‰²
                            game.backgroundFlash.currentColorIndex =
                                (game.backgroundFlash.currentColorIndex + 1) % game.backgroundFlash.colors.length;
                            game.backgroundFlash.targetColor = game.backgroundFlash.colors[game.backgroundFlash.currentColorIndex];
                        }
                    }

                    if (game.heat < 3) {
                        game.heat++;
                        if (game.heat === 3) {
                            game.heatMode = true;
                        }
                    }
                }

                // ç –å—ç¢°æ’
                for (const brick of game.bricks) {
                    if (brick.alive && !brick.breaking && checkBrickCollision(ball, brick)) {
                        // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¸å¼¹ç –å—
                        if (brick.type === 'bomb') {
                            // ç‚¸å¼¹çˆ†ç‚¸ï¼šå¼•çˆ†å‘¨å›´ç –å—
                            explodeBomb(brick);
                        } else {
                            // æ™®é€šç –å—ï¼šç”Ÿæˆç¢ç‰‡ç²’å­
                            createBrickParticles(brick);
                            playBombSound();
                        }

                        brick.breaking = true;
                        brick.breakStartTime = Date.now();
                        ball.vy = -ball.vy;

                        // å¢åŠ åˆ†æ•°ï¼ˆä½¿ç”¨çƒ­åŠ›æ¨¡å¼åŠ æˆï¼‰
                        game.score += calculateScore();
                        break;
                    }
                }
            }

            // æ£€æŸ¥ç –å—è§¦åº•ï¼ˆæ¸¸æˆå¤±è´¥æ¡ä»¶ï¼‰
            // åº•çº¿ä½ç½®ï¼šç¬¬18è¡Œï¼ˆç¬¬17è¡Œç´¢å¼•ï¼Œä»0å¼€å§‹ï¼‰
            const deathLineY = CONFIG.brickOffsetTop + CONFIG.deathLine * (CONFIG.brickHeight + CONFIG.brickPadding);
            for (const brick of game.bricks) {
                if (brick.alive && brick.y >= deathLineY) {
                    if (!gameOver) {
                        gameOver = true;
                        showGameOver('ç –å—è§¦åº•ï¼æ¸¸æˆç»“æŸï¼');
                    }
                    break;
                }
            }

            // æ£€æŸ¥èƒœåˆ©
            const aliveBricks = game.bricks.filter(b => b.alive).length;
            if (aliveBricks === 0 && !gameOver) {
                gameOver = true;
                showGameOver('æ­å–œèƒœåˆ©ï¼');
            }

            updateUI();
        }

        function checkPaddleCollision(ball) {
            const paddleLeft = game.paddle.x - game.paddle.width / 2;
            const paddleRight = game.paddle.x + game.paddle.width / 2;
            const paddleTop = game.paddle.y - game.paddle.height / 2;
            const paddleBottom = game.paddle.y + game.paddle.height / 2;

            return ball.x + CONFIG.ballRadius > paddleLeft &&
                   ball.x - CONFIG.ballRadius < paddleRight &&
                   ball.y + CONFIG.ballRadius > paddleTop &&
                   ball.y - CONFIG.ballRadius < paddleBottom &&
                   ball.vy > 0;
        }

        function checkBrickCollision(ball, brick) {
            return ball.x + CONFIG.ballRadius > brick.x &&
                   ball.x - CONFIG.ballRadius < brick.x + brick.width &&
                   ball.y + CONFIG.ballRadius > brick.y &&
                   ball.y - CONFIG.ballRadius < brick.y + brick.height;
        }

        function renderGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶èƒŒæ™¯ï¼ˆæŒä¹…è‰²+æ‰©æ•£åŠ¨ç”»ï¼‰
            if (game.backgroundFlash.active) {
                const elapsed = Date.now() - game.backgroundFlash.startTime;
                const progress = elapsed / game.backgroundFlash.duration;

                if (progress < 1) {
                    // å…ˆç»˜åˆ¶å½“å‰èƒŒæ™¯è‰²
                    ctx.fillStyle = game.backgroundFlash.currentBgColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // åˆ›å»ºä»ä¸­å¿ƒæ‰©æ•£çš„åœ†å½¢é®ç½©æ•ˆæœ
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY);

                    // æ‰©æ•£åŠå¾„ï¼šæ›´å¤§èŒƒå›´ï¼Œç¡®ä¿å®Œå…¨è¦†ç›–
                    const radius = progress * maxRadius * 2.5;

                    // é€æ˜åº¦ï¼šä¿æŒä¸é€æ˜ï¼Œè®©é¢œè‰²å®Œå…¨è¦†ç›–
                    const alpha = 1;

                    // ç»˜åˆ¶ç›®æ ‡é¢œè‰²çš„æ‰å¹³è‰²åœ†å½¢
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = game.backgroundFlash.targetColor;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else {
                    // æ‰©æ•£å®Œæˆï¼Œæ›´æ–°å½“å‰èƒŒæ™¯è‰²ä¸ºç›®æ ‡è‰²
                    game.backgroundFlash.currentBgColor = game.backgroundFlash.targetColor;
                    game.backgroundFlash.active = false;

                    // ç»˜åˆ¶æœ€ç»ˆèƒŒæ™¯è‰²
                    ctx.fillStyle = game.backgroundFlash.currentBgColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            } else {
                // ç»˜åˆ¶å½“å‰æŒä¹…èƒŒæ™¯è‰²
                ctx.fillStyle = game.backgroundFlash.currentBgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // ç»˜åˆ¶è‹¥éšè‹¥ç°çš„åº•çº¿ï¼ˆè§¦åº•è­¦ç¤ºçº¿ï¼‰
            const deathLineY = CONFIG.brickOffsetTop + CONFIG.deathLine * (CONFIG.brickHeight + CONFIG.brickPadding);
            const time = Date.now() / 1000;
            const breatheAlpha = 0.15 + Math.sin(time * 2) * 0.1;  // 0.05-0.25ä¹‹é—´å‘¼å¸

            // ç»˜åˆ¶è™šçº¿
            ctx.strokeStyle = `rgba(255, 80, 80, ${breatheAlpha})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);  // è™šçº¿æ ·å¼ï¼š10pxå®çº¿ï¼Œ5pxç©ºç™½
            ctx.beginPath();
            ctx.moveTo(0, deathLineY);
            ctx.lineTo(canvas.width, deathLineY);
            ctx.stroke();
            ctx.setLineDash([]);  // é‡ç½®ä¸ºå®çº¿

            // æ·»åŠ å¾®å¼±çš„å…‰æ™•æ•ˆæœ
            ctx.shadowColor = `rgba(255, 80, 80, ${breatheAlpha * 0.5})`;
            ctx.shadowBlur = 8;
            ctx.strokeStyle = `rgba(255, 80, 80, ${breatheAlpha * 0.3})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, deathLineY);
            ctx.lineTo(canvas.width, deathLineY);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // ç»˜åˆ¶ç –å—
            for (const brick of game.bricks) {
                if (brick.alive) {
                    if (brick.breaking) {
                        const elapsed = Date.now() - brick.breakStartTime;
                        const progress = elapsed / 60;

                        ctx.save();
                        const scale = 1 - progress * 0.3;
                        const alpha = 1 - progress;
                        const offsetX = brick.x + brick.width / 2;
                        const offsetY = brick.y + brick.height / 2;

                        ctx.translate(offsetX, offsetY);
                        ctx.scale(scale, scale);
                        ctx.globalAlpha = alpha;

                        ctx.fillStyle = brick.color;
                        ctx.shadowColor = brick.color;
                        ctx.shadowBlur = 8;
                        ctx.fillRect(-brick.width/2, -brick.height/2, brick.width, brick.height);
                        ctx.shadowBlur = 0;

                        ctx.restore();
                    } else {
                        // ç‚¸å¼¹ç –å—ï¼šéœ“è™¹è‰²ç›¸å˜åŒ–ï¼ˆå¿«é€Ÿï¼‰
                        if (brick.type === 'bomb') {
                            const time = Date.now() / 1000;
                            const hue = (time * 240) % 360;  // è‰²ç›¸æ¯ç§’æ—‹è½¬240åº¦ï¼ˆé€Ÿåº¦ç¿»å€ï¼‰
                            const saturation = 80 + Math.sin(time * 6) * 20;  // é¥±å’Œåº¦60-100%å˜åŒ–ï¼ˆé€Ÿåº¦ç¿»å€ï¼‰
                            const lightness = 50 + Math.sin(time * 8) * 10;  // äº®åº¦40-60%å˜åŒ–ï¼ˆé€Ÿåº¦ç¿»å€ï¼‰

                            ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                            ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
                            ctx.shadowBlur = 15;
                            ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                            ctx.shadowBlur = 0;

                            // æ·»åŠ é¢å¤–çš„éœ“è™¹è¾¹æ¡†æ•ˆæœ
                            ctx.strokeStyle = `hsl(${hue}, 100%, 70%)`;
                            ctx.lineWidth = 2;
                            ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
                            ctx.shadowBlur = 8;
                            ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                            ctx.shadowBlur = 0;
                        } else {
                            // æ™®é€šç –å—
                            ctx.fillStyle = brick.color;
                            ctx.shadowColor = brick.color;
                            ctx.shadowBlur = 6;
                            ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                            ctx.shadowBlur = 0;

                            ctx.fillStyle = 'rgba(255,255,255,0.3)';
                            ctx.fillRect(brick.x, brick.y, brick.width, 2);
                        }
                    }
                }
            }

            // ç»˜åˆ¶ç –å—ç¢ç‰‡ç²’å­
            for (const p of game.particles) {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                ctx.globalAlpha = p.life;

                // ç»˜åˆ¶å°æ–¹å—ç¢ç‰‡
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);

                // æ·»åŠ é«˜å…‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, 1);

                ctx.restore();
            }

            // ç»˜åˆ¶æŒ¡æ¿ï¼ˆæ°´å¹³ï¼Œæ— æ—‹è½¬ï¼‰
            ctx.save();
            ctx.translate(game.paddle.x, game.paddle.y);

            const gradient = ctx.createLinearGradient(0, -game.paddle.height/2, 0, game.paddle.height/2);
            gradient.addColorStop(0, '#56ab2f');
            gradient.addColorStop(1, 'rgba(86, 171, 47, 0.7)');
            ctx.fillStyle = gradient;
            ctx.shadowColor = '#56ab2f';
            ctx.shadowBlur = 12;
            ctx.fillRect(-game.paddle.width/2, -game.paddle.height/2, game.paddle.width, game.paddle.height);
            ctx.shadowBlur = 0;

            ctx.restore();

            // ç»˜åˆ¶çƒï¼ˆå¸¦æ‹–å°¾æ•ˆæœï¼‰
            for (const ball of game.balls) {
                // å…ˆç»˜åˆ¶æ‹–å°¾
                if (ball.trail && ball.trail.length > 1) {
                    for (let i = 0; i < ball.trail.length; i++) {
                        const progress = i / ball.trail.length;
                        const alpha = progress * 0.6; // ä»0åˆ°0.6çš„é€æ˜åº¦
                        const size = CONFIG.ballRadius * (0.3 + progress * 0.7); // ä»30%åˆ°100%çš„å¤§å°

                        ctx.beginPath();
                        ctx.arc(ball.trail[i].x, ball.trail[i].y, size, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(251, 191, 36, ${alpha})`; // é‡‘è‰² #fbbf24
                        ctx.shadowColor = `rgba(251, 191, 36, ${alpha * 0.5})`;
                        ctx.shadowBlur = 8;
                        ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                }

                // å†ç»˜åˆ¶çƒæœ¬ä½“ï¼ˆåœ¨æœ€ä¸Šå±‚ï¼‰
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, CONFIG.ballRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#fbbf24';
                ctx.shadowColor = '#fbbf24';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // ç»˜åˆ¶çƒ­åŠ›æ¡
            const barWidth = canvas.width - 20;
            const barHeight = 8;
            const barX = 10;
            const barY = 30;

            let speedMultiplier = 1.0;
            const normalBall = game.balls.find(b => b.type === 'normal');
            if (normalBall) {
                const currentSpeed = Math.sqrt(normalBall.vx * normalBall.vx + normalBall.vy * normalBall.vy);
                speedMultiplier = currentSpeed / CONFIG.ballSpeed;
            }

            const textColor = game.heatMode ? '#ff4444' : '#ffffff';
            ctx.fillStyle = textColor;
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('çƒ­åŠ›å€¼', barX, barY - 5);

            ctx.textAlign = 'center';
            ctx.fillText('x' + speedMultiplier.toFixed(1), canvas.width / 2, barY - 5);

            ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            const heatProgress = game.heat / 3;
            const heatWidth = barWidth * heatProgress;

            if (game.heatMode) {
                const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(255, 50, 50, ${pulse})`;
            } else {
                ctx.fillStyle = '#ff4444';
            }

            ctx.fillRect(barX, barY, heatWidth, barHeight);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 1; i < 3; i++) {
                const x = barX + (barWidth / 3) * i;
                ctx.beginPath();
                ctx.moveTo(x, barY);
                ctx.lineTo(x, barY + barHeight);
                ctx.stroke();
            }

            // ç»˜åˆ¶Comboæç¤º
            if (game.comboDisplay.show) {
                const elapsed = Date.now() - game.comboDisplay.startTime;
                const duration = 400;

                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    const alpha = Math.sin(progress * Math.PI);
                    let scale;
                    if (progress < 0.3) {
                        scale = 0.5 + (progress / 0.3) * 0.7;
                    } else {
                        scale = 1.2 - ((progress - 0.3) / 0.7) * 0.2;
                    }
                    const offsetY = -20 * Math.sin(progress * Math.PI);

                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2 + offsetY);
                    ctx.scale(scale, scale);

                    ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                    ctx.font = 'bold 36px Segoe UI';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = `rgba(255, 215, 0, ${alpha * 0.8})`;
                    ctx.shadowBlur = 20;

                    ctx.fillText(`${game.comboDisplay.value} x Combo`, 0, 0);

                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else {
                    game.comboDisplay.show = false;
                }
            }

            // æç¤ºæ–‡å­—
            if (game.balls.length === 0 && !gameOver) {
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = '16px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('æ¡æ‹³â†’å¼ å¼€å‘çƒ', canvas.width/2, canvas.height/2);
            }
        }

        function updateUI() {
            // æ›´æ–°é¡¶éƒ¨æ 
            document.getElementById('headerScore').textContent = game.score;

            // æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤ºï¼ˆåˆ†:ç§’ï¼‰
            const minutes = Math.floor(game.gameTime / 60);
            const seconds = game.gameTime % 60;
            document.getElementById('headerTime').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // æ›´æ–°è°ƒè¯•é¢æ¿ FPS æ˜¾ç¤º
            if (debugCheckbox.checked) {
                const fpsEl = document.getElementById('fpsValue');
                if (fpsEl) {
                    fpsEl.textContent = currentFPS;
                    // æ ¹æ®å¸§ç‡æ˜¾ç¤ºä¸åŒé¢œè‰²
                    if (currentFPS >= 55) {
                        fpsEl.style.color = '#4ade80'; // ç»¿è‰² - è‰¯å¥½
                    } else if (currentFPS >= 30) {
                        fpsEl.style.color = '#fbbf24'; // é»„è‰² - ä¸€èˆ¬
                    } else {
                        fpsEl.style.color = '#ef4444'; // çº¢è‰² - è¾ƒå·®
                    }
                }
            }
        }

        function showGameOver(message = 'æ¸¸æˆç»“æŸ') {
            document.getElementById('finalScore').textContent = game.score;
            document.getElementById('maxCombo').textContent = game.maxCombo;

            // æ›´æ–°æ¸¸æˆç»“æŸæ¶ˆæ¯
            const gameOverTitle = document.querySelector('#gameOverOverlay h2');
            if (gameOverTitle) {
                gameOverTitle.textContent = message;
            }

            document.getElementById('gameOverOverlay').classList.add('show');
        }

        function restartGame() {
            gameOver = false;
            game.balls = [];
            game.particles = [];  // æ¸…ç©ºç²’å­
            game.score = 0;
            game.heat = 0;
            game.heatMode = false;
            game.combo = 0;
            game.maxCombo = 0;
            game.startTime = 0;
            game.gameTime = 60;  // é‡ç½®å€’è®¡æ—¶ä¸º60ç§’
            game.nextRowTime = 0;  // é‡ç½®æ–°è¡Œæ—¶é—´
            game.brickTransition.active = false;  // é‡ç½®è¿‡æ¸¡åŠ¨ç”»
            game.backgroundFlash.currentBgColor = '#0f0f23';  // é‡ç½®èƒŒæ™¯è‰²
            initBricks();
            document.getElementById('gameOverOverlay').classList.remove('show');
        }

        function gameLoop(currentTime) {
            // è®¡ç®— delta time
            if (lastFrameTime === 0) {
                lastFrameTime = currentTime;
            }
            deltaTime = (currentTime - lastFrameTime) / TARGET_FRAME_TIME; // æ ‡å‡†åŒ–ä¸ºç›®æ ‡å¸§æ—¶é—´çš„å€æ•°
            lastFrameTime = currentTime;

            // é™åˆ¶ delta time é˜²æ­¢è·³å¸§è¿‡å¤§ï¼ˆå¦‚åˆ‡æ¢æ ‡ç­¾é¡µåï¼‰
            if (deltaTime > 3) deltaTime = 3;

            // è®¡ç®— FPS
            frameCount++;
            if (currentTime - fpsLastTime >= 1000) {
                currentFPS = frameCount;
                frameCount = 0;
                fpsLastTime = currentTime;
            }

            updateGame(deltaTime);
            renderGame();
            requestAnimationFrame(gameLoop);
        }

        // ============ åˆå§‹åŒ– ============
        async function init() {
            const statusEl = document.getElementById('status');

            initBricks();

            try {
                statusEl.innerHTML = '<span style="color: #888">æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...</span>';

                const video = document.createElement('video');
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 }
                });
                video.srcObject = stream;
                await video.play();

                statusEl.innerHTML = '<span style="color: #888">æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹...</span>';

                const camera = new Camera(video, {
                    onFrame: async () => {
                        await hands.send({ image: video });
                    },
                    width: 640,
                    height: 480
                });

                await camera.start();

                statusEl.innerHTML = '<span class="active">âœ“ è¿è¡Œä¸­</span>';

                gameLoop();

            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                statusEl.innerHTML = `<span style="color: #ef4444">é”™è¯¯: ${error.message}</span>`;
            }
        }

        init();
    </script>
</body>
</html>
